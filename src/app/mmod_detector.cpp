//
// Created by azgra on 16.11.17.
//

#include "mmod_detector.h"
#include <dlib/dnn.h>
#include <dlib/data_io.h>
#include <dlib/gui_widgets.h>

using namespace std;
using namespace dlib;

//5x5 conv layer that does 2x downsampling
template <long num_filters, typename SUBNET> using con5d = con<num_filters, 5, 5, 2, 2, SUBNET>;

//3x3 conv layer that does not do any downsampling?
template <long num_filters, typename SUBNET> using con3 = con<num_filters, 3, 3, 1, 1, SUBNET>;

//downsampler 3x con5d => 8x downsampling; relu and batch normalization in standard way?
template <typename SUBNET> using downsampler = relu<bn_con<con5d<32, relu<bn_con<con5d<32, relu<bn_con<con5d<32, SUBNET>>>>>>>>>;

//3x3 conv layer with batch normalization and relu.
template <typename SUBNET> using rcon3 = relu<bn_con<con3<32, SUBNET>>>;

// The special input_rgb_image_pyramid
// layer causes the network to operate over a spatial pyramid, making the detector
// scale invariant.

using net_type = loss_mmod<con<1, 6, 6, 1, 1, rcon3<rcon3<rcon3<downsampler<input_rgb_image_pyramid<pyramid_down<6>>>>>>>>;


int mmod_train(int argc, char ** argv, bool train, bool test)
{
    try {


        if (argc != 4) {
            cout << "Give the path to the examples/faces directory as the argument to this" << endl;
            cout << "program.  For example, if you are in the examples folder then execute " << endl;
            cout << "this program by running: " << endl;
            cout << "   ./dnn_mmod_ex faces" << endl;
            cout << endl;
            return 0;
        }


        const std::string faces_directory = argv[1];
        //training data are annotated with rectangles around object which you want to detect.

        std::vector<matrix<rgb_pixel>> images_train, images_test;
        std::vector<std::vector<mmod_rect>> face_boxes_train, face_boxes_test;

        load_image_dataset(images_train, face_boxes_train, faces_directory + "/training.xml");
        load_image_dataset(images_test, face_boxes_test, faces_directory + "/testing.xml");


        cout << "Number of training images " << images_train.size() << endl;
        cout << "Number of testing images " << images_test.size() << endl;

        //40x40 is target size when the object you want to detect is still recongnizable. Smaller the better.
        mmod_options options(face_boxes_train, 40, 40);

        cout << "Number of sliding windows " << options.detector_windows.size() << endl;

        for (mmod_options::detector_window_details &x : options.detector_windows) {
            cout << "Width of window: " << x.width << "; Height of window: " << x.height << endl;
        }

        cout << "Overlap NMS IOU thresh: " << options.overlaps_nms.get_iou_thresh() << endl;
        cout << "Overlap NMS percent covered thresh: " << options.overlaps_nms.get_percent_covered_thresh() << endl;

        net_type net(options);

        cout << "Net structure:" << endl;
        cout << net << endl;


        // Number of filters in the final network layer must be equal to number of windows.
        net.subnet().layer_details().set_num_filters(options.detector_windows.size());

        dnn_trainer<net_type> trainer(net);

        trainer.set_learning_rate(0.1);
        trainer.be_verbose();
        trainer.set_synchronization_file("mmod_sync", std::chrono::minutes(5));
        trainer.set_iterations_without_progress_threshold(300);

        //http://dlib.net/random_cropper_ex.cpp.html
        random_cropper cropper;

        //crop to 200x200?
        cropper.set_chip_dims(200, 200);
        cropper.set_min_object_size(0.2);

        dlib::rand rnd;

        //ACTUAL TRAINING
        //using mini batches of 150 images. Being generated by random_cropper.cpp
        if (train) {


            unsigned int batch_size = 150;

            std::vector<matrix<rgb_pixel>> mini_batch_samples;
            std::vector<std::vector<mmod_rect>> mini_batch_labels;



            while (trainer.get_learning_rate() >= 1e-4) {
                cropper(batch_size, images_train, face_boxes_train, mini_batch_samples, mini_batch_labels);

                //randomly jitter colors
                for (auto &&img : mini_batch_samples) {
                    disturb_colors(img, rnd);
                }

                trainer.train_one_step(mini_batch_samples, mini_batch_labels);
            }

            trainer.get_net();

            cout << "Done training" << endl;

            net.clean();

            serialize("mmod_data.dat") << net;
        }

        cout << "test is: " << test << endl;
        if (test) {

            deserialize("mmod_data.dat") >> net;



            cout << "training results: " << test_object_detection_function(net, images_train, face_boxes_train);

            cout << "testing results: " << test_object_detection_function(net, images_test, face_boxes_test);

            cout << "*************************" << endl;
            cout << "Settings used" << endl;

            cout << trainer << cropper << endl;

            cout << "*************************" << endl;

            //testing actual test imgs, show result in window
            image_window window;
            for (auto &&img : images_test) {
                pyramid_up(img);

                auto dets = net(img);

                window.clear_overlay();

                window.set_image(img);

                for (auto &&d : dets) {
                    window.add_overlay(d);
                }

                cin.get();

            }
        }
    }

    catch (std::exception & e)
    {
        cout << "Exception occured!" << endl;
        cout << e.what() << endl;
        return 1;
    }

    return 0;
}














































